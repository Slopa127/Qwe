<!DOCTYPE html>
<html lang="en">
<head>
  <title>Simple FPS Step 2: Shooting</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; color: white; font-family: monospace; }
    #info {
      position: absolute; top: 10px; left: 10px; padding: 10px; background: rgba(0,0,0,0.5); border-radius: 5px;
      user-select: none;
      z-index: 100;
    }
  </style>
</head>
<body>
<div id="info">Click to lock pointer. WASD to move. Left click to shoot.</div>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
  import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/controls/PointerLockControls.js';

  let camera, scene, renderer, controls;
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();

  const bullets = [];
  const targets = [];

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => {
      controls.lock();
    });

    scene.add(controls.getObject());

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(100, 100);
    const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, side: THREE.DoubleSide });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Create multiple targets
    for(let i = 0; i < 3; i++) {
      const targetGeometry = new THREE.BoxGeometry(1, 2, 1);
      const targetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const target = new THREE.Mesh(targetGeometry, targetMaterial);
      target.position.set((i - 1) * 5, 1, -15); // Spread targets in front
      scene.add(target);
      targets.push({ mesh: target, health: 3 });
    }

    window.addEventListener('resize', onWindowResize);

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('mousedown', shoot);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onKeyDown(event) {
    switch(event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = true;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = true;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = true;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = true;
        break;
    }
  }

  function onKeyUp(event) {
    switch(event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = false;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = false;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = false;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = false;
        break;
    }
  }

  function shoot(event) {
    if (!controls.isLocked) return;
    if (event.button !== 0) return; // Left click only

    const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

    // Start position: camera position
    bullet.position.copy(controls.getObject().position);

    // Direction: camera forward
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);

    bullet.userData = {
      velocity: direction.multiplyScalar(1),
      aliveTime: 0
    };

    scene.add(bullet);
    bullets.push(bullet);
  }

  function animate() {
    requestAnimationFrame(animate);

    if (controls.isLocked === true) {
      const speed = 0.1;
      velocity.x = 0;
      velocity.z = 0;

      if (moveForward) velocity.z -= speed;
      if (moveBackward) velocity.z += speed;
      if (moveLeft) velocity.x -= speed;
      if (moveRight) velocity.x += speed;

      direction.copy(velocity).applyEuler(camera.rotation);
      controls.getObject().position.add(direction);

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity);

        b.userData.aliveTime += 1;
        if (b.userData.aliveTime > 200) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }

        // Check collision with targets (simple distance)
        for (let j = targets.length - 1; j >= 0; j--) {
          const t = targets[j];
          if (t.mesh.position.distanceTo(b.position) < 1) {
            t.health--;
            if (t.health <= 0) {
              scene.remove(t.mesh);
              targets.splice(j, 1);
            }
            scene.remove(b);
            bullets.splice(i, 1);
            break;
          }
        }
      }
    }

    renderer.render(scene, camera);
  }
</script>
</body>
</html>
